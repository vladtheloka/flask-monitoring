"""
This type stub file was generated by pyright.
"""

import sys
import operator
from functools import partial, wraps
from flask import abort as original_flask_abort, current_app, make_response as original_flask_make_response, request, url_for
from flask.views import MethodView
from flask.signals import got_request_exception
from werkzeug.datastructures import Headers
from werkzeug.exceptions import HTTPException, InternalServerError, MethodNotAllowed, NotAcceptable, NotFound
from werkzeug.wrappers import Response as ResponseBase
from flask_restful.utils import OrderedDict, http_status_message, unpack
from flask_restful.representations.json import output_json
from types import MethodType
from collections.abc import Mapping

_PROPAGATE_EXCEPTIONS = ...
__all__ = ('Api', 'Resource', 'marshal', 'marshal_with', 'marshal_with_field', 'abort')
def abort(http_status_code, **kwargs):
    """Raise a HTTPException for the given http_status_code. Attach any keyword
    arguments to the exception for later processing.
    """
    ...

DEFAULT_REPRESENTATIONS = ...
class Api:
    """
    The main entry point for the application.
    You need to initialize it with a Flask Application: ::

    >>> app = Flask(__name__)
    >>> api = restful.Api(app)

    Alternatively, you can use :meth:`init_app` to set the Flask application
    after it has been constructed.

    :param app: the Flask application object
    :type app: flask.Flask or flask.Blueprint
    :param prefix: Prefix all routes with a value, eg v1 or 2010-04-01
    :type prefix: str
    :param default_mediatype: The default media type to return
    :type default_mediatype: str
    :param decorators: Decorators to attach to every resource
    :type decorators: list
    :param catch_all_404s: Use :meth:`handle_error`
        to handle 404 errors throughout your app
    :param serve_challenge_on_401: Whether to serve a challenge response to
        clients on receiving 401. This usually leads to a username/password
        popup in web browsers.
    :param url_part_order: A string that controls the order that the pieces
        of the url are concatenated when the full url is constructed.  'b'
        is the blueprint (or blueprint registration) prefix, 'a' is the api
        prefix, and 'e' is the path component the endpoint is added with
    :type catch_all_404s: bool
    :param errors: A dictionary to define a custom response for each
        exception or error raised during a request
    :type errors: dict

    """
    def __init__(self, app=..., prefix=..., default_mediatype=..., decorators=..., catch_all_404s=..., serve_challenge_on_401=..., url_part_order=..., errors=...) -> None:
        ...
    
    def init_app(self, app): # -> None:
        """Initialize this class with the given :class:`flask.Flask`
        application or :class:`flask.Blueprint` object.

        :param app: the Flask application or blueprint object
        :type app: flask.Flask
        :type app: flask.Blueprint

        Examples::

            api = Api()
            api.add_resource(...)
            api.init_app(app)

        """
        ...
    
    def owns_endpoint(self, endpoint): # -> bool:
        """Tests if an endpoint name (not path) belongs to this Api.  Takes
        in to account the Blueprint name part of the endpoint name.

        :param endpoint: The name of the endpoint being checked
        :return: bool
        """
        ...
    
    def error_router(self, original_handler, e): # -> werkzeug.sansio.response.Response | flask.wrappers.Response:
        """This function decides whether the error occured in a flask-restful
        endpoint or not. If it happened in a flask-restful endpoint, our
        handler will be dispatched. If it happened in an unrelated view, the
        app's original error handler will be dispatched.
        In the event that the error occurred in a flask-restful endpoint but
        the local handler can't resolve the situation, the router will fall
        back onto the original_handler as last resort.

        :param original_handler: the original Flask error handler for the app
        :type original_handler: function
        :param e: the exception raised while handling the request
        :type e: Exception

        """
        ...
    
    def handle_error(self, e): # -> werkzeug.sansio.response.Response | flask.wrappers.Response:
        """Error handler for the API transforms a raised exception into a Flask
        response, with the appropriate HTTP status code and body.

        :param e: the raised Exception object
        :type e: Exception

        """
        ...
    
    def mediatypes_method(self): # -> Callable[..., list[str]]:
        """Return a method that returns a list of mediatypes
        """
        ...
    
    def add_resource(self, resource, *urls, **kwargs): # -> None:
        """Adds a resource to the api.

        :param resource: the class name of your resource
        :type resource: :class:`Type[Resource]`

        :param urls: one or more url routes to match for the resource, standard
                     flask routing rules apply.  Any url variables will be
                     passed to the resource method as args.
        :type urls: str

        :param endpoint: endpoint name (defaults to :meth:`Resource.__name__.lower`
            Can be used to reference this route in :class:`fields.Url` fields
        :type endpoint: str

        :param resource_class_args: args to be forwarded to the constructor of
            the resource.
        :type resource_class_args: tuple

        :param resource_class_kwargs: kwargs to be forwarded to the constructor
            of the resource.
        :type resource_class_kwargs: dict

        Additional keyword arguments not specified above will be passed as-is
        to :meth:`flask.Flask.add_url_rule`.

        Examples::

            api.add_resource(HelloWorld, '/', '/hello')
            api.add_resource(Foo, '/foo', endpoint="foo")
            api.add_resource(FooSpecial, '/special/foo', endpoint="foo")

        """
        ...
    
    def resource(self, *urls, **kwargs): # -> Callable[..., Any]:
        """Wraps a :class:`~flask_restful.Resource` class, adding it to the
        api. Parameters are the same as :meth:`~flask_restful.Api.add_resource`.

        Example::

            app = Flask(__name__)
            api = restful.Api(app)

            @api.resource('/foo')
            class Foo(Resource):
                def get(self):
                    return 'Hello, World!'

        """
        ...
    
    def output(self, resource): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], werkzeug.wrappers.response.Response | Any | flask.wrappers.Response]:
        """Wraps a resource (as a flask view function), for cases where the
        resource does not directly return a response object

        :param resource: The resource as a flask view function
        """
        ...
    
    def url_for(self, resource, **values): # -> str:
        """Generates a URL to the given resource.

        Works like :func:`flask.url_for`."""
        ...
    
    def make_response(self, data, *args, **kwargs): # -> Response:
        """Looks up the representation transformer for the requested media
        type, invoking the transformer to create a response object. This
        defaults to default_mediatype if no transformer is found for the
        requested mediatype. If default_mediatype is None, a 406 Not
        Acceptable response will be sent as per RFC 2616 section 14.1

        :param data: Python object containing response data to be transformed
        """
        ...
    
    def mediatypes(self): # -> list[str]:
        """Returns a list of requested mediatypes sent in the Accept header"""
        ...
    
    def representation(self, mediatype): # -> Callable[..., Any]:
        """Allows additional representation transformers to be declared for the
        api. Transformers are functions that must be decorated with this
        method, passing the mediatype the transformer represents. Three
        arguments are passed to the transformer:

        * The data to be represented in the response body
        * The http status code
        * A dictionary of headers

        The transformer should convert the data appropriately for the mediatype
        and return a Flask response object.

        Ex::

            @api.representation('application/xml')
            def xml(data, code, headers):
                resp = make_response(convert_data_to_xml(data), code)
                resp.headers.extend(headers)
                return resp
        """
        ...
    
    def unauthorized(self, response):
        """ Given a response, change it to ask for credentials """
        ...
    


class Resource(MethodView):
    """
    Represents an abstract RESTful resource. Concrete resources should
    extend from this class and expose methods for each supported HTTP
    method. If a resource is invoked with an unsupported HTTP method,
    the API will return a response with status 405 Method Not Allowed.
    Otherwise the appropriate method is called and passed all arguments
    from the url rule used when adding the resource to an Api instance. See
    :meth:`~flask_restful.Api.add_resource` for details.
    """
    representations = ...
    method_decorators = ...
    def dispatch_request(self, *args, **kwargs): # -> Response | Any:
        ...
    


def marshal(data, fields, envelope=...): # -> list[Any | list[Any]]:
    """Takes raw data (in the form of a dict, list, object) and a dict of
    fields to output and filters the data based on those fields.

    :param data: the actual object(s) from which the fields are taken from
    :param fields: a dict of whose keys will make up the final serialized
                   response output
    :param envelope: optional key that will be used to envelop the serialized
                     response


    >>> from flask_restful import fields, marshal
    >>> data = { 'a': 100, 'b': 'foo' }
    >>> mfields = { 'a': fields.Raw }

    >>> marshal(data, mfields)
    OrderedDict([('a', 100)])

    >>> marshal(data, mfields, envelope='data')
    OrderedDict([('data', OrderedDict([('a', 100)]))])

    """
    ...

class marshal_with:
    """A decorator that apply marshalling to the return values of your methods.

    >>> from flask_restful import fields, marshal_with
    >>> mfields = { 'a': fields.Raw }
    >>> @marshal_with(mfields)
    ... def get():
    ...     return { 'a': 100, 'b': 'foo' }
    ...
    ...
    >>> get()
    OrderedDict([('a', 100)])

    >>> @marshal_with(mfields, envelope='data')
    ... def get():
    ...     return { 'a': 100, 'b': 'foo' }
    ...
    ...
    >>> get()
    OrderedDict([('data', OrderedDict([('a', 100)]))])

    see :meth:`flask_restful.marshal`
    """
    def __init__(self, fields, envelope=...) -> None:
        """
        :param fields: a dict of whose keys will make up the final
                       serialized response output
        :param envelope: optional key that will be used to envelop the serialized
                         response
        """
        ...
    
    def __call__(self, f): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], tuple[Any | list[Any], Any | Literal[200], Any | dict[Any, Any]] | Any | list[Any | list[Any]]]:
        ...
    


class marshal_with_field:
    """
    A decorator that formats the return values of your methods with a single field.

    >>> from flask_restful import marshal_with_field, fields
    >>> @marshal_with_field(fields.List(fields.Integer))
    ... def get():
    ...     return ['1', 2, 3.0]
    ...
    >>> get()
    [1, 2, 3]

    see :meth:`flask_restful.marshal_with`
    """
    def __init__(self, field) -> None:
        """
        :param field: a single field with which to marshal the output.
        """
        ...
    
    def __call__(self, f): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], tuple[Any, Any | Literal[200], Any | dict[Any, Any]] | Any]:
        ...
    


